{% extends "layouts/base.html" %}

{% block title %}ESP32 하드웨어 테스트{% endblock %}

{% block body_class %}hardware-test-page{% endblock %}

{% block content %}
<style>
    .hardware-test-container {
        padding: 15px;
        height: 100vh;
        display: flex;
        flex-direction: column;
        font-family: 'Noto Sans KR', sans-serif;
        gap: 15px;
        box-sizing: border-box;
    }

    /* 상단 모터 테스트 영역 (50%) */
    .motor-test-section {
        flex: 1;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        flex-direction: column;
    }

    .section-title {
        font-size: 1.3em;
        font-weight: bold;
        margin-bottom: 20px;
        color: #ffffff;
        text-align: center;
    }

    .motor-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 20px;
    }

    .motor-btn {
        padding: 20px;
        border: none;
        border-radius: 12px;
        font-size: 1.1em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .motor-btn-icon {
        font-size: 1.5em;
    }

    .motor-btn-forward {
        background: linear-gradient(45deg, #4CAF50, #66BB6A);
    }

    .motor-btn-reverse {
        background: linear-gradient(45deg, #2196F3, #42A5F5);
    }

    .motor-btn-auto {
        background: linear-gradient(45deg, #FF9800, #FFB74D);
        grid-column: span 2;
    }

    .motor-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }

    .motor-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
    }

    .motor-status {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 15px;
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
        max-height: 150px;
        overflow-y: auto;
        color: #E0E0E0;
    }

    /* 하단 센서 상태 영역 (50%) */
    .sensor-status-section {
        flex: 1;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        flex-direction: column;
    }

    .sensor-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 15px;
        margin-top: 20px;
        flex: 1;
    }

    .sensor-item {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 15px;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.2);
        font-size: 1em;
        font-weight: bold;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 5px;
        transition: all 0.3s ease;
        position: relative;
    }

    .sensor-number {
        font-size: 1.3em;
        margin-bottom: 5px;
    }

    .sensor-status {
        font-size: 0.8em;
        opacity: 0.8;
    }

    .sensor-connected {
        background: rgba(46, 125, 50, 0.3);
        border-color: #4CAF50;
    }

    .sensor-disconnected {
        background: rgba(158, 158, 158, 0.3);
        border-color: #9E9E9E;
        color: #BDBDBD;
    }

    .sensor-triggered {
        background: rgba(244, 67, 54, 0.8) !important;
        border-color: #F44336 !important;
        box-shadow: 0 0 20px rgba(244, 67, 54, 0.6);
        animation: pulse 1s infinite;
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .sensor-count {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #FF5722;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 0.7em;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }

    .loading {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px 40px;
        border-radius: 10px;
        z-index: 1000;
    }

    .home-btn {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(158, 158, 158, 0.8);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 1.2em;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 100;
    }

    .home-btn:hover {
        background: rgba(158, 158, 158, 1);
        transform: scale(1.1);
    }

    .log-entry {
        margin-bottom: 5px;
        padding: 3px 6px;
        border-radius: 3px;
        font-size: 0.8em;
    }

    .log-success {
        background: rgba(76, 175, 80, 0.3);
        color: #A5D6A7;
    }

    .log-error {
        background: rgba(244, 67, 54, 0.3);
        color: #EF9A9A;
    }

    .log-info {
        background: rgba(33, 150, 243, 0.3);
        color: #90CAF9;
    }
</style>

<div class="hardware-test-container">
    <!-- 홈 버튼 -->
    <button class="home-btn" onclick="goHome()">🏠</button>
    
    <!-- 로딩 인디케이터 -->
    <div id="loading" class="loading">처리 중...</div>
    
    <!-- 상단: 모터 테스트 영역 -->
    <div class="motor-test-section">
        <div class="section-title">⚙️ 모터 제어 테스트</div>
        
        <div class="motor-controls">
            <button class="motor-btn motor-btn-forward" onclick="rotateMotor330()">
                <div class="motor-btn-icon">🔄</div>
                <div>330도 회전</div>
            </button>
            
            <button class="motor-btn motor-btn-reverse" onclick="rotateMotorReverse()">
                <div class="motor-btn-icon">↩️</div>
                <div>원위치 복귀</div>
            </button>
            
            <button class="motor-btn motor-btn-auto" onclick="toggleAutoMode()" id="autoModeBtn">
                <div class="motor-btn-icon">🤖</div>
                <div id="autoModeText">자동모드 활성화</div>
            </button>
        </div>
        
        <div class="motor-controls" style="margin-top: 10px;">
            <button class="motor-btn" style="background: linear-gradient(45deg, #9C27B0, #BA68C8); grid-column: span 2;" onclick="testSensorTrigger()">
                <div class="motor-btn-icon">🧪</div>
                <div>센서 테스트 (센서1 트리거)</div>
            </button>
        </div>
        
        <div class="motor-status" id="motorLog">
            <div class="log-entry log-info">모터 제어 시스템 준비됨</div>
        </div>
    </div>
    
    <!-- 하단: 센서 상태 영역 -->
    <div class="sensor-status-section">
        <div class="section-title">📡 센서 상태 모니터링 (실시간)</div>
        
        <div class="sensor-grid">
            <!-- 센서 1-10번 -->
            <div class="sensor-item sensor-disconnected" id="sensor1">
                <div class="sensor-number">1</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count1" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor2">
                <div class="sensor-number">2</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count2" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor3">
                <div class="sensor-number">3</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count3" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor4">
                <div class="sensor-number">4</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count4" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor5">
                <div class="sensor-number">5</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count5" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor6">
                <div class="sensor-number">6</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count6" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor7">
                <div class="sensor-number">7</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count7" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor8">
                <div class="sensor-number">8</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count8" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor9">
                <div class="sensor-number">9</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count9" style="display: none;">0</div>
            </div>
            <div class="sensor-item sensor-disconnected" id="sensor10">
                <div class="sensor-number">10</div>
                <div class="sensor-status">연결 안됨</div>
                <div class="sensor-count" id="count10" style="display: none;">0</div>
            </div>
        </div>
    </div>
</div>

<script>
// 전역 변수
let eventSource = null;
let autoModeEnabled = false;
let sensorCounts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0};
let sensorTimers = {};

// 실제 로그에서 확인된 연결 센서들 (4,7,8,9번 등)
const connectedSensors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 페이지 로드 시 초기화
document.addEventListener('DOMContentLoaded', function() {
    // 연결된 센서 상태 먼저 설정
    initializeSensorStates();
    
    // 실시간 이벤트 연결 시작
    initializeEventStream();
});

// 실시간 이벤트 스트림 초기화
function initializeEventStream() {
    try {
        addMotorLog('🔄 실시간 센서 모니터링 시작', 'info');
        
        // 1. 새로운 이벤트 확인 (1초마다)
        setInterval(async function() {
            try {
                const response = await fetch('/api/hardware/sensor_events');
                if (response.ok) {
                    const events = await response.json();
                    if (events.length > 0) {
                        console.log('🔥 [이벤트] 센서 이벤트 수신:', events.length, '개');
                        events.forEach(event => {
                            console.log('🔥 [이벤트] 이벤트 처리:', event);
                            handleSensorEventDirect(event);
                        });
                    }
                }
            } catch (error) {
                console.error('🔥 [이벤트] 오류:', error);
            }
        }, 1000);
        
        // 2. 현재 센서 상태 주기적 확인 (3초마다)
        setInterval(async function() {
            try {
                const response = await fetch('/api/hardware/sensor_status');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.sensors) {
                        console.log('🔥 [상태폴링] 센서 상태 업데이트:', data.sensors);
                        
                        // 각 센서의 현재 상태를 UI에 반영
                        Object.entries(data.sensors).forEach(([sensorNum, state]) => {
                            updateSensorStatusDirect(parseInt(sensorNum), state);
                        });
                    }
                }
            } catch (error) {
                console.error('🔥 [상태폴링] 오류:', error);
            }
        }, 3000); // 3초마다 상태 폴링
        
        addMotorLog('✅ 혼합 모니터링 활성화 (이벤트 + 상태폴링)', 'success');
        
    } catch (error) {
        addMotorLog('❌ 실시간 모니터링 실패: ' + error.message, 'error');
        console.error('이벤트 스트림 오류:', error);
    }
}

// 폴링 모드 (WebSocket 실패시 대안)
function startPollingMode() {
    addMotorLog('센서 폴링 모드 시작', 'info');
    
    // 1초마다 센서 상태 확인
    setInterval(async function() {
        try {
            const response = await fetch('/api/hardware/status');
            const data = await response.json();
            // 센서 데이터가 있으면 처리
            if (data.sensor_events) {
                data.sensor_events.forEach(event => {
                    handleSensorEventDirect(event);
                });
            }
        } catch (error) {
            console.log('폴링 오류:', error);
        }
    }, 1000);
}

// 센서 초기 상태 설정
function initializeSensorStates() {
    addMotorLog('센서 상태 초기화 중...', 'info');
    
    // 모든 센서를 먼저 연결 안됨으로 설정
    for (let i = 1; i <= 10; i++) {
        const sensorElement = document.getElementById(`sensor${i}`);
        if (sensorElement) {
            sensorElement.className = 'sensor-item sensor-disconnected';
            sensorElement.querySelector('.sensor-status').textContent = '연결 안됨';
        }
    }
    
    // 연결된 센서만 연결됨으로 변경
    connectedSensors.forEach(sensorNum => {
        const sensorElement = document.getElementById(`sensor${sensorNum}`);
        if (sensorElement) {
            sensorElement.className = 'sensor-item sensor-connected';
            sensorElement.querySelector('.sensor-status').textContent = '미감지';
            addMotorLog(`센서 ${sensorNum}번 연결됨`, 'success');
        }
    });
    
    addMotorLog(`총 ${connectedSensors.length}개 센서 연결 완료`, 'success');
}

// ESP32 이벤트 처리
function handleESP32Event(data) {
    console.log('ESP32 이벤트:', data);
    
    if (data.event_type === 'sensor_triggered') {
        handleSensorEvent(data.data);
    } else if (data.event_type === 'motor_completed') {
        handleMotorEvent(data.data);
    } else if (data.event_type === 'barcode_scanned') {
        addMotorLog(`바코드 스캔: ${data.data.barcode}`, 'info');
    }
}

// 센서 이벤트 처리 (WebSocket)
function handleSensorEvent(sensorData) {
    const addr = sensorData.addr;
    const pin = sensorData.pin;
    const state = sensorData.raw;
    
    // 핀 번호를 센서 번호로 매핑
    const pinToSensor = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 8: 9, 9: 10};
    const sensorNum = pinToSensor[pin];
    
    if (sensorNum && connectedSensors.includes(sensorNum)) {
        updateSensorStatus(sensorNum, state);
        addMotorLog(`센서 ${sensorNum}: ${state}`, 'info');
    }
}

// 센서 이벤트 처리 (폴링 모드)
function handleSensorEventDirect(eventData) {
    // 직접 센서 번호와 상태를 받는 경우
    if (eventData.sensor_num && eventData.state) {
        updateSensorStatus(eventData.sensor_num, eventData.state);
        addMotorLog(`센서 ${eventData.sensor_num}: ${eventData.state}`, 'info');
    }
}

// 센서 상태 업데이트 (실시간 반영)
function updateSensorStatus(sensorNum, state) {
    const sensorElement = document.getElementById(`sensor${sensorNum}`);
    const countElement = document.getElementById(`count${sensorNum}`);
    
    if (!sensorElement) return;
    
    // 상태에 따른 시각적 변화 (실시간)
    if (state === 'LOW') {
        // 센서 트리거됨 (물체 감지) - 계속 유지
        if (sensorElement.className !== 'sensor-item sensor-triggered') {
            // 처음 감지될 때만 카운트 증가
            sensorCounts[sensorNum]++;
            countElement.textContent = sensorCounts[sensorNum];
            countElement.style.display = 'flex';
            
            addMotorLog(`센서 ${sensorNum}: 감지됨 (물체 있음)`, 'info');
        }
        
        sensorElement.className = 'sensor-item sensor-triggered';
        sensorElement.querySelector('.sensor-status').textContent = '감지됨!';
        
    } else {
        // 센서 미감지 (물체 없음)
        if (sensorElement.className === 'sensor-item sensor-triggered') {
            addMotorLog(`센서 ${sensorNum}: 미감지 (물체 제거됨)`, 'info');
        }
        
        sensorElement.className = 'sensor-item sensor-connected';
        sensorElement.querySelector('.sensor-status').textContent = '미감지';
    }
}

// 직접 센서 상태 업데이트 (카운트 증가 없이)
function updateSensorStatusDirect(sensorNum, state) {
    const sensorElement = document.getElementById(`sensor${sensorNum}`);
    
    if (!sensorElement) return;
    
    // 현재 상태와 다른 경우에만 업데이트
    const currentTriggered = sensorElement.className.includes('sensor-triggered');
    const shouldBeTriggered = (state === 'LOW');
    
    if (currentTriggered !== shouldBeTriggered) {
        if (shouldBeTriggered) {
            sensorElement.className = 'sensor-item sensor-triggered';
            sensorElement.querySelector('.sensor-status').textContent = '감지됨!';
            console.log(`🔥 [직접업데이트] 센서 ${sensorNum}: 감지됨`);
        } else {
            sensorElement.className = 'sensor-item sensor-connected';
            sensorElement.querySelector('.sensor-status').textContent = '미감지';
            console.log(`🔥 [직접업데이트] 센서 ${sensorNum}: 미감지`);
        }
    }
}

// 모터 이벤트 처리
function handleMotorEvent(motorData) {
    const action = motorData.action;
    const status = motorData.status;
    addMotorLog(`모터 ${action}: ${status}`, 'success');
}

// 모터 로그 추가
function addMotorLog(message, type = 'info') {
    const logContainer = document.getElementById('motorLog');
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry log-${type}`;
    logEntry.textContent = `[${timestamp}] ${message}`;
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // 최대 50개 로그만 유지
    const entries = logContainer.children;
    if (entries.length > 50) {
        logContainer.removeChild(entries[0]);
    }
}

// 로딩 표시/숨기기
function showLoading(message = '처리 중...') {
    const loading = document.getElementById('loading');
    loading.textContent = message;
    loading.style.display = 'block';
}

function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}

// 모터 제어 함수들
async function rotateMotor330() {
    showLoading('모터 회전 중...');
    addMotorLog('330도 정방향 회전 시작', 'info');
    
    try {
        const response = await fetch('/api/hardware/motor_move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                revs: 0.9167,  // 330도
                rpm: 60,
                accel: true
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            addMotorLog('330도 회전 명령 전송 완료', 'success');
        } else {
            addMotorLog(`회전 실패: ${result.error}`, 'error');
        }
    } catch (error) {
        addMotorLog(`오류: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

async function rotateMotorReverse() {
    showLoading('원위치 복귀 중...');
    addMotorLog('330도 역방향 회전 시작', 'info');
    
    try {
        const response = await fetch('/api/hardware/motor_move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                revs: -0.9167,  // -330도 (역방향)
                rpm: 60,
                accel: true
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            addMotorLog('원위치 복귀 명령 전송 완료', 'success');
        } else {
            addMotorLog(`복귀 실패: ${result.error}`, 'error');
        }
    } catch (error) {
        addMotorLog(`오류: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

async function toggleAutoMode() {
    showLoading('자동모드 설정 중...');
    autoModeEnabled = !autoModeEnabled;
    
    try {
        const response = await fetch('/api/hardware/auto_mode', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                enabled: autoModeEnabled
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            const btnText = document.getElementById('autoModeText');
            const btn = document.getElementById('autoModeBtn');
            
            if (autoModeEnabled) {
                btnText.textContent = '자동모드 비활성화';
                btn.style.background = 'linear-gradient(45deg, #F44336, #EF5350)';
                addMotorLog('자동모드 활성화됨', 'success');
            } else {
                btnText.textContent = '자동모드 활성화';
                btn.style.background = 'linear-gradient(45deg, #FF9800, #FFB74D)';
                addMotorLog('자동모드 비활성화됨', 'info');
            }
        } else {
            addMotorLog(`자동모드 설정 실패: ${result.error}`, 'error');
        }
    } catch (error) {
        addMotorLog(`오류: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}

// 센서 테스트 (시뮬레이션)
function testSensorTrigger() {
    addMotorLog('센서 1번 테스트 트리거', 'info');
    
    // 센서 1번을 트리거 상태로 변경
    updateSensorStatus(1, 'LOW');
    
    // 2초 후 원래 상태로 복원
    setTimeout(() => {
        const sensorElement = document.getElementById('sensor1');
        if (sensorElement) {
            sensorElement.className = 'sensor-item sensor-connected';
            sensorElement.querySelector('.sensor-status').textContent = '미감지';
        }
        addMotorLog('센서 1번 테스트 완료', 'success');
    }, 2000);
}

// 홈으로 돌아가기
function goHome() {
    window.location.href = '/';
}
</script>
{% endblock %}